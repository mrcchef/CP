{
	"CP Template": {
		"prefix": "cp",
		"body": [
		  "//LinkedIn:https://www.linkedin.com/in/abhijeettamrakar/",
		  "//GitHub:https://github.com/mrcchef/",
		  "#include <bits/stdc++.h>",
		  "",
		  "// policy based data structure ",
		  "#include<ext/pb_ds/assoc_container.hpp>",
		  "#include<ext/pb_ds/tree_policy.hpp>",
		  "",
		  "using namespace __gnu_pbds;",
		  "using namespace std;",
		  "",
		  "typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds; ",
		  "// find_by_order : finding ith element, order_of_key : number of element smaller than key",
		  "",
		  "#define fastio ios_base::sync_with_stdio(false); cin.tie(0) ; cout.tie(0);",
		  "",
		  "#ifndef ONLINE_JUDGE",
		  "    #define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;",
		  "#else",
		  "    #define debug(x);",
		  "#endif",
		  " ",
		  "#define fo(i,n) for(i=0;i<n;i++)",
		  "#define Fo(i,k,n) for(i=k;i<=n;i++)",
		  "#define ll long long",
		  "#define ull unsigned long long",
		  "#define lld long double",
		  "#define ff first",
		  "#define ss second",
		  "#define pb push_back",
		  "#define mp make_pair",
		  "#define mii map<ll,ll>",
		  "#define pii pair<ll,ll>",
		  "#define vi vector<ll>",
		  "#define endl \"\\n\"",
		  "const ll MOD = 1e9+7;",
		  "const ll MOD1= 998244353;",
		  "const ll inf=1e18;",
		  "#define popcount(x) __builtin_popcount(x)",
		  "#define all(x) x.begin(),x.end()",
		  "#define mem(a,v) memset(a,v,sizeof(a))",
		  "#define Max(x,y,z) max(x,max(y,z))",
		  "#define Min(x,y,z) min(x,min(y,z))",
		  "",
		  "// debugging code",
		  "// ---------------------------------------------------------------------------------------------------------------------------------",
		  "void _print(ll t) {cerr << t;}",
		  "void _print(int t) {cerr << t;}",
		  "void _print(string t) {cerr << t;}",
		  "void _print(char t) {cerr << t;}",
		  "void _print(lld t) {cerr << t;}",
		  "void _print(double t) {cerr << t;}",
		  "void _print(ull t) {cerr << t;}",
		  "",
		  "template <class T, class V> void _print(pair <T, V> p);",
		  "template <class T> void _print(vector <T> v);",
		  "template <class T> void _print(set <T> v);",
		  "template <class T, class V> void _print(map <T, V> v);",
		  "template <class T> void _print(multiset <T> v);",
		  "template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.ff); cerr << \",\"; _print(p.ss); cerr << \"}\";}",
		  "template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
		  "template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
		  "template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
		  "template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
		  "// ---------------------------------------------------------------------------------------------------------------------------------",
		  "",
		  "ll dx[]={-1,0,1,0};",
		  "ll dy[]={0,-1,0,1};",
		  "",
		  "void swap(ll &a,ll &b);",
		  "ll m_m(ll a,ll b,ll m);",
		  "ll fxp(ll a,ll b,ll m);",
		  "ll msum(ll a,ll b,ll m);",
		  "ll msub(ll a,ll b,ll m);",
		  "ll mpro(ll a,ll b,ll m);",
		  "",
		  "void solve()",
		  "{",
		  "    ",
		  "}",
		  "",
		  "int main()",
		  "{",
		  "    fastio",
		  "    #ifdef ONLINE_JUDGE",
		  "        // freopen(\"input.txt\", \"r\", stdin); ",
		  "        // freopen(\"output.txt\", \"w\", stdout);",
		  "        freopen(\"error.txt\",\"w\",stderr);",
		  "    #endif",
		  "    int t=1;",
		  "    cin>>t;",
		  "    while(t--)",
		  "    {",
		  "        solve();   ",
		  "    }",
		  " return 0;",
		  "}",
		  "",
		  "ll fxp(ll a,ll b,ll m) {",
		  "    if(b==0)",
		  "        return 1;",
		  "    if(b%2==0)",
		  "        return fxp((a*a)%m,b/2,m);",
		  "    return (fxp(a,b-1,m)*a)%m;",
		  "}",
		  "ll m_m(ll a,ll b,ll m) ",
		  "{",
		  "    ll res=0;",
		  "    a=a%m;",
		  "    while(b)",
		  "    {",
		  "        if(b&1)",
		  "        {",
		  "            res+=a; ",
		  "            res=res%m;",
		  "        }",
		  "        a=(a*2)%m;",
		  "        b=b/2;",
		  "    }",
		  "    return res;",
		  "}",
		  "void swap(ll &a,ll &b){ ll t=a; a=b; b=t;}",
		  "ll msum(ll a,ll b,ll m) { return ((a%m+b%m)+m)%m; }",
		  "ll msub(ll a,ll b,ll m) { return ((a%m-b%m)+m)%m; }",
		  "ll mpro(ll a,ll b,ll m) { return (((a%m)*(b%m)+m))%m; }"
		],
		"description": "CP Template"
	  },
	  "NCR": {
		  "prefix": "ncr",
		  "body": [
			"const int N=5000;",
			"#define PRIME mod",
			"",
			"ll fact[N],invfact[N];",
			"void init(){",
			"    ll p=PRIME;",
			"    fact[0]=1;",
			"    ll i;",
			"    for(i=1;i<N;i++){",
			"        fact[i]=i*fact[i-1]%p;",
			"    }",
			"    i--;",
			"    invfact[i]=fxp(fact[i],p-2,p);",
			"    for(i--;i>=0;i--){",
			"        invfact[i]=invfact[i+1]*(i+1)%p;",
			"    }",
			"}",
			"",
			"ll ncr(ll n,ll r)",
			"{",
			"    if(n<0 || r<0 || n<r) ",
			"        return 0;",
			"    return fact[n]*invfact[n-r]%PRIME*invfact[r]%PRIME;",
			"}"
		  ],
		  "description": "NCR"
		},

		"Graph": {
			"prefix": "Graph",
			"body": [
			  "class Graph{",
			  "    ll V;",
			  "    list<ll> *l;",
			  "    ll root;",
			  "    public:",
			  "        Graph(ll V)",
			  "        {",
			  "            this->V=V;",
			  "            l=new list<ll>[V];",
			  "            root=0;",
			  "        }",
			  "",
			  "        void add_edge(ll x,ll y)",
			  "        {",
			  "            l[x].pb(y);",
			  "            l[y].pb(x);",
			  "        }",
			  "",
			  "        void dfs_helper(ll cur,bool visited[])",
			  "        {",
			  "            visited[cur]=true;",
			  "",
			  "            for(auto nbr:l[cur])",
			  "            {",
			  "                if(visited[nbr])",
			  "                    continue;",
			  "                dfs_helper(nbr,visited);",
			  "            }",
			  "        }",
			  "",
			  "        void dfs()",
			  "        {",
			  "            bool visited[V]={false};",
			  "",
			  "            dfs_helper(root,visited);",
			  "        }",
			  "",
			  "};"
			],
			"description": "Graph"
		  },
		  "SIEVE": {
			"prefix": "sieve",
			"body": [
			  "const ll N=1e6+5;",
			  "vi prime;",
			  "bool check[N];",
			  "",
			  "void cal()",
			  "{",
			  "    for(ll i=1;i<=N;i++)",
			  "        check[i]=true;",
			  "    check[0]=check[1]=false;",
			  "    for(ll i=2;i<=N;i++)",
			  "    {",
			  "        if(check[i]==1)",
			  "        {",
			  "            prime.pb(i);",
			  "            for(ll j=i*i;j<=N;j+=i)",
			  "                check[j]=0;",
			  "        }",
			  "    } ",
			  "}"
			],
			"description": "SIEVE"
		  },
		  "segment tree": {
			"prefix": "seg",
			"body": [
			  "// Commented area needs to be changed according to the need",
			  "// this segment tree is for range sum queries",
			  "struct SegTree{",
			  "    struct node{",
			  "        // variable",
			  "        ll sum ;",
			  "        node(){ // constructor ",
			  "            sum = 0;",
			  "        }",
			  "        // + operator overloading",
			  "        friend node const operator + (const node &a,const node &b){",
			  "            node res;",
			  "            res.sum = a.sum + b.sum;",
			  "            return res;",
			  "        }",
			  "    };",
			  "    int n;",
			  "    vector<node> v; ",
			  "    node dummy; // dummy node",
			  "    SegTree(int n){",
			  "        this->n = n;",
			  "        v.assign(4*n+10,dummy);",
			  "    }",
			  "    void update(int id,const int pos,const int val,int s,int e){",
			  "        if(s>e) return;",
			  "        if(s==e){ // base case",
			  "            v[id].sum += val;",
			  "            return;",
			  "        }",
			  "        int mid = (s+e)/2;",
			  "        if(pos<=mid) update(2*id,pos,val,s,mid);",
			  "        else update(2*id+1,pos,val,mid+1,e);",
			  "        // operation after updation of child nodes",
			  "        v[id] = v[2*id] + v[2*id+1];",
			  "        return;",
			  "    }",
			  "    void update(const int pos,const int val){",
			  "        update(1,pos,val,1,n);",
			  "    }",
			  "    node query(int id,const int l,const int r,const int s,const int e){",
			  "        if(s>e || r<s || l>e) return dummy;",
			  "        else if(l<=s && e<=r) return v[id];",
			  "        else return query(2*id,l,r,s,(s+e)/2) + query(2*id+1,l,r,(s+e)/2+1,e);",
			  "        // above else return is query dependent",
			  "    }",
			  "    node query(const int l,const int r){",
			  "        return query(1,l,r,1,n);",
			  "    }",
			  "    ll get(int l,int r){",
			  "        return query(l,r).sum;",
			  "    }",
			  "};"
			],
			"description": "segment tree"
		  },
		  "fenwickTree": {
			"prefix": "fen",
			"body": [
			  "class fenwick{",
			  "    public:",
			  "        long long n;",
			  "        vector<long long> fen;",
			  "        ",
			  "        fenwick(ll sz)",
			  "        {   ",
			  "            n=sz;",
			  "            fen.assign(sz+1,0);",
			  "        }",
			  "        ",
			  "        void update(long long in,long long val)",
			  "        {",
			  "            long long i=in;",
			  "            while(i<=n)",
			  "            {",
			  "                fen[i]+=val;",
			  "                i=i+(i&(-i));",
			  "            }",
			  "        }",
			  "",
			  "        long long sum(long long in)",
			  "        {",
			  "            long long i=in;",
			  "            long long sm=0;",
			  "            while(i>=1)",
			  "            {",
			  "                sm+=fen[i];",
			  "                i=i-(i&(-i));",
			  "            }",
			  "",
			  "            return sm;",
			  "        }",
			  "",
			  "        long long rsum(long long l,long long r)",
			  "        {",
			  "            return sum(r)-sum(l-1);",
			  "        }",
			  "",
			  "        void rupdate(long long l,long long r,long long val)",
			  "        {",
			  "            update(l,val);",
			  "            if(r+1>n)",
			  "                return;",
			  "            update(r+1,-val);",
			  "        }",
			  "",
			  "        int findLowerBound(long long val)",
			  "        {",
			  "            int cur=0;",
			  "            int prevsum=0;",
			  "",
			  "            for(int i=log2(n);i>=0;i--)",
			  "            {",
			  "                if((cur+(1LL<<i))<=n && prevsum+fen[cur+(1LL<<i)]<val)",
			  "                {",
			  "                    cur=cur+(1LL<<i);",
			  "                    prevsum+=fen[cur];",
			  "                }",
			  "            }",
			  "",
			  "            return (cur+1);",
			  "        }",
			  "};"
			],
			"description": "fenwickTree"
		  },
		  "mos algorithm": {
			"prefix": "mo",
			"body": [
			  "const ll MAXELE=1e6+5; // max range of elements",
			  "const ll BLK=700; // block size",
			  "",
			  "struct data{",
			  "    ll l,r,in;",
			  "    data(){}",
			  "",
			  "    data(ll _l,ll _r,ll _in)",
			  "    {",
			  "        l=_l;",
			  "        r=_r;",
			  "        in=_in;",
			  "    }",
			  "};",
			  "",
			  "bool compare(data &d1,data &d2)",
			  "{",
			  "    if(d1.l/BLK==d2.l/BLK)",
			  "        return d1.r<d2.r;",
			  "    return d1.l<d2.l;",
			  "}",
			  "",
			  "class MosAlgo{",
			  "    public:",
			  "    ll ML,MR,cnt,q;",
			  "    // ML and MR are zero based indexes",
			  "    vector<data> query;",
			  "    vi arr;",
			  "    vi freq;",
			  "",
			  "    MosAlgo(ll _q,vector<data> _query,vector<ll> _arr)",
			  "    {",
			  "        q=_q,query=_query,arr=_arr,ML=0,MR=-1,cnt=0,freq.assign(MAXELE,0);",
			  "    }",
			  "",
			  "    void addMo(ll in)",
			  "    {",
			  "        freq[arr[in]]++;",
			  "        if(freq[arr[in]]==1)",
			  "            cnt++;",
			  "    }",
			  "",
			  "    void removeMo(ll in)",
			  "    {",
			  "        freq[arr[in]]--;",
			  "        if(freq[arr[in]]==0)",
			  "            cnt--;",
			  "    }",
			  "",
			  "    vi mos()",
			  "    {",
			  "        ll i;",
			  "        vi ans(q);",
			  "        fo(i,q)",
			  "        {",
			  "            ll l=query[i].l;",
			  "            ll r=query[i].r;",
			  "            //add",
			  "            while(MR<r)",
			  "                MR++,addMo(MR);",
			  "",
			  "            while(ML>l)",
			  "                ML--,addMo(ML);",
			  "",
			  "            // remove",
			  "            while(MR>r)",
			  "                removeMo(MR),MR--;",
			  "",
			  "            while(ML<l)",
			  "                removeMo(ML),ML++;",
			  "            ans[query[i].in]=cnt;",
			  "        }",
			  "        return ans;",
			  "    }",
			  "};"
			],
			"description": "mos algorithm"
		  },
		  "dsu": {
			"prefix": "dsu",
			"body": [
			  "class DSU{",
			  "    public:",
			  "    ll n;",
			  "    vi parent;",
			  "    vi rank;",
			  "    ",
			  "    DSU(ll n)",
			  "    {",
			  "        this->n=n;",
			  "        parent=vi(n+1,-1);",
			  "        rank=vi(n+1,1);",
			  "    }",
			  "",
			  "    ll getParent(ll node)",
			  "    {",
			  "        if(parent[node]==-1)",
			  "            return node;",
			  "        return parent[node]=getParent(parent[node]);",
			  "    }",
			  "",
			  "    bool isCyclePresent(ll node1,ll node2)",
			  "    {",
			  "        ll par1=getParent(node1);",
			  "        ll par2=getParent(node2);",
			  "",
			  "        return par1==par2;",
			  "    }",
			  "",
			  "    bool mergeSet(ll node1,ll node2)",
			  "    {",
			  "        ll par1=getParent(node1);",
			  "        ll par2=getParent(node2);",
			  "",
			  "        if(par1==par2)",
			  "            return false;",
			  "        ",
			  "        if(rank[par1]<rank[par2])",
			  "        {",
			  "            parent[par1]=par2;",
			  "            rank[par2]+=rank[par1];",
			  "        }",
			  "        else",
			  "        {",
			  "            parent[par2]=par1;",
			  "            rank[par1]+=rank[par2];",
			  "        }",
			  "",
			  "        return true;",
			  "    }",
			  "};"
			],
			"description": "dsu"
		  },
		  "binaryLift": {
			"prefix": "binaryLift",
			"body": [
			  "const ll N=2e5+5;",
			  "",
			  "vector<vi> g(N);",
			  "",
			  "vi level(N);",
			  "ll mx=20;",
			  "vector<vi> up(N,vi(mx));",
			  "",
			  "void binary_lifting(ll node,ll par,ll lvl)",
			  "{",
			  "    up[node][0]=par;",
			  "    level[node]=lvl;",
			  "",
			  "    for(ll i=1;i<mx;i++)",
			  "    {",
			  "        if(up[node][i-1]==-1)",
			  "            up[node][i]=-1;",
			  "        else",
			  "            up[node][i]=up[up[node][i-1]][i-1];",
			  "    }",
			  "",
			  "    for(auto nbr:g[node])",
			  "    {",
			  "        if(nbr==par)",
			  "            continue;",
			  "        binary_lifting(nbr,node,lvl+1);",
			  "    }",
			  "}",
			  "",
			  "",
			  "ll up_lift(ll node,ll lvl)",
			  "{",
			  "    ll des=node;",
			  "",
			  "    for(ll i=mx-1;i>=0;i--)",
			  "    {",
			  "        if(node==-1 || lvl==0)",
			  "            return node;",
			  "",
			  "        if(lvl>=(1<<i))",
			  "        {",
			  "            node=up[node][i];",
			  "            lvl-=(1<<i);",
			  "        }",
			  "    }",
			  "",
			  "    return node;",
			  "}",
			  "",
			  "ll getLca(ll node1,ll node2)",
			  "{",
			  "    if(level[node1]>level[node2])",
			  "    {",
			  "        swap(node1,node2);",
			  "    }",
			  "",
			  "    node2=up_lift(node2,level[node2]-level[node1]);",
			  "",
			  "    if(node2==node1)",
			  "        return node1;",
			  "",
			  "    for(ll i=mx-1;i>=0;i--)",
			  "    {",
			  "        if(up[node1][i]!=up[node2][i])",
			  "        {",
			  "            node1=up[node1][i];",
			  "            node2=up[node2][i];",
			  "        }",
			  "    }",
			  "",
			  "    return up[node1][0];",
			  "}"
			],
			"description": "binaryLift"
		  }
}
